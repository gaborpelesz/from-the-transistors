`timescale 1ns / 1ps

module ALU32(
    input  wire [3:0] op_ALU,
           wire [31:0] DIN0, DIN1,
           wire Carry_IN, // can carry for exmpl. ADC, or carry generated by the barrel shifter
           wire Neg_IN,
           wire Zero_IN,
           wire V_IN, // oVerflow
    output reg  [31:0] DOUT,
           reg  Carry_OUT,
           wire Neg_OUT,
           wire Zero_OUT,
           reg  V_OUT // oVerflow
    );
    
    /*  Data-processing instructions
        ARM ARM page 115
    */
    localparam
    op_AND = 4'b0000, // bitwise AND
    op_EOR = 4'b0001, // bitwise XOR
    op_SUB = 4'b0010, // subtract
    op_RSB = 4'b0011, // reverse subtract; note: to negate val in <Rm> use " RSBS <Rd>, <Rm>, #0 "
    op_ADD = 4'b0100, // add
    op_ADC = 4'b0101, // add with carry
    op_SBC = 4'b0110, // subtract with carry
    op_RSC = 4'b0111, // reverse subtract with carry
    op_TST = 4'b1000, // test
    op_TEQ = 4'b1001, // test equivalence
    op_CMP = 4'b1010, // compare
    op_CMN = 4'b1011, // compare negated
    op_ORR = 4'b1100, // or
    op_MOV = 4'b1101, // move, only important when updating CPSR
    op_BIC = 4'b1110, // bit clear
    op_MVN = 4'b1111; // move not, only important when updating CPSR
    
    /*
    op_ASR = 4'd3,  // Arithmetic shift right
    op_LSL = 4'd8,  // logical shift left
    op_LSR = 4'd9,  // logical shift right
    op_MUL = 4'd10, // multiply
    op_NEG = 4'd11, // negate
    op_ROR = 4'd13, // rotate right
    ;*/
    
    /* ADDER MODULE */
    reg ADD32_CIN = 0;
    wire [31:0] ADD32_OUT = 0;
    wire ADD32_COUT, ADD32_V;
    mADD32 ADD32 (DIN0, DIN1, ADD32_CIN, ADD32_OUT, ADD32_COUT, ADD32_V);
    
    /* SUBTRACT MODULE */
    reg SUB32_CIN = 1;
    reg [31:0] SUB_IN0 = 0, SUB_IN1 = 0;
    wire [31:0] SUB32_OUT;
    wire SUB32_COUT, SUB32_V;
    mSUB32 SUB32 (SUB_IN0, SUB_IN1, SUB32_CIN, SUB32_OUT, SUB32_COUT, SUB32_V);
    
    always @ (op_ALU)
    begin
        /* bitwise AND */
        if (op_ALU == op_AND || op_ALU == op_TST) // TST and AND are effectively the same
        begin
            DOUT      <= DIN0 & DIN1; // execute operation
            // CPSR special case when <Rd> is R15, control should handle.
            Carry_OUT <= Carry_IN;
            V_OUT     <= V_IN;
        end
        
        /* bitwise XOR */
        else if (op_ALU == op_EOR || op_ALU == op_TEQ)
        begin
            DOUT      <= DIN0 ^ DIN1;
            // CPSR special case when <Rd> is R15, control should handle.
            Carry_OUT <= Carry_IN;
            V_OUT     <= V_IN;
        end

        /* subtract */
        else if (op_ALU == op_SUB || op_ALU == op_CMP) // CMP and SUB are effectively the same
        begin
            // Inputs
            SUB32_CIN <= 1;         // no borrow occurs
            SUB_IN0 <= DIN0;
            SUB_IN1 <= DIN1;
            
            // Outputs
            DOUT      <= SUB32_OUT;
            Carry_OUT <= SUB32_COUT;
            V_OUT     <= SUB32_V;
        end
        
        /* reverse subtract */
        else if (op_ALU == op_RSB)
        begin
            // Inputs
            SUB32_CIN <= 1;         // no borrow occurs
            SUB_IN0 <= DIN1;
            SUB_IN1 <= DIN0;
            
            // Outputs
            DOUT      <= SUB32_OUT;
            Carry_OUT <= SUB32_COUT;
            V_OUT     <= SUB32_V;
        end

        else if (op_ALU == op_ADD || op_ALU == op_CMN) // CMN and ADD are effectively the same
        begin
            // Inputs
            ADD32_CIN <= 0;
            
            // Outputs
            DOUT      <= ADD32_OUT;
            Carry_OUT <= ADD32_COUT;
            V_OUT     <= ADD32_V;
        end
        
        else if (op_ALU == op_ADC)
        begin
            // Inputs
            ADD32_CIN <= Carry_IN;
            
            // Outputs
            DOUT      <= ADD32_OUT;
            Carry_OUT <= ADD32_COUT;
            V_OUT     <= ADD32_V;
        end
        
        /* subtract with carry */
        else if (op_ALU == op_SBC)
        begin
            // Inputs
            SUB32_CIN <= Carry_IN;
            SUB_IN0 <= DIN0;
            SUB_IN1 <= DIN1;
            
            // Outputs
            DOUT      <= SUB32_OUT;
            Carry_OUT <= SUB32_COUT;
            V_OUT     <= SUB32_V;
        end
        
        /* reverse subtract with carry */
        else if (op_ALU == op_RSC)
        begin
            // Inputs
            SUB32_CIN <= Carry_IN;
            SUB_IN0 <= DIN1;
            SUB_IN1 <= DIN0;
            
            // Outputs
            DOUT      <= SUB32_OUT;
            Carry_OUT <= SUB32_COUT;
            V_OUT     <= SUB32_V;
        end
        
        else if (op_ALU == op_ORR)
        begin
            DOUT      <= DIN0 | DIN1;
            Carry_OUT <= Carry_IN; // shifter carry out
            V_OUT     <= V_IN;
        end
        
        else if (op_ALU == op_MOV)
        begin
            DOUT      <= DIN1; // result is the shifter operand
            Carry_OUT <= Carry_IN; // shifter carry out
            V_OUT     <= V_IN;
        end
        
        else if (op_ALU == op_BIC)
        begin
            DOUT      <= DIN0 & ~DIN1;
            Carry_OUT <= Carry_IN; // shifter carry out
            V_OUT     <= V_IN;
        end
        
        else if (op_ALU == op_MVN)
        begin
            DOUT      <= ~DIN1; // result is the shifter operand
            Carry_OUT <= Carry_IN; // shifter carry out
            V_OUT     <= V_IN;
        end
        
    end // always @ (op_ALU)
    
    /* Status bits */
    assign Neg_OUT = DOUT[31];
    assign Zero_OUT = DOUT == 0;
    
endmodule
